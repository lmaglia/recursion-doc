\documentclass{beamer}
\usepackage[british]{babel}
\usepackage{graphics,hyperref,url}
\usepackage{amsmath}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\MakeRobust{\Call}
\usetheme{Boadilla}
% title of the presentation
% - first a short version which is visible at the bottom of each slide;
% - second the full title shown on the title slide;
\title[Tail Recursion Elimination]{Tail Recursion Elimination}
\subtitle{Recursive to iterative transformation}
% Tha author of the presentation:
% - again first a short version to be displayed at the bottom;
% - next the full list of authors, which may include contact information;
\author[Lucas M. Magliarelli]{
	Lucas M. Magliarelli 
}

% The institute:
% - to start the name of the university as displayed on the top of each slide
%   this can be adjusted such that you can also create a Dutch version
% - next the institute information as displayed on the title slide
\institute[TradeHelm Inc.]{
	TradeHelm Inc.
}
% add a date and possibly the name of the event to the slides
% - again first a short version to be shown at the bottom of each slide
% - second the full date and event name for the title slide
\date[March, 2018]{
	the 1st. presentation 2018
}
\begin{document}
\begin{frame}
	\titlepage
\end{frame}
\begin{frame}
	\frametitle{Outline}
	\tableofcontents
\end{frame}
\section{Introduction}
\begin{frame}
	\frametitle{Introduction}
	Recursive programs are usually very descriptive, easy to code and to understand. However, they can have some issues:
	\begin{itemize}
		\item Recursive programs are executed by computers and computers have limitations
		\item Recursion, in computers, is implemented by using a stack
		\item a Stack is a portion of memory of fixed length. This sets a limit in the amount of invocations of the recursive calls. When such limit is reached, \texttt{StackOverflowException} is thrown
		\item Besides, every recursive call has to push their parameters and local variables into the stack and this is expensive
		\item Some recursive algorithms repeat calculations, that is, the recursive call is invoked with the same parameters many times. The running time of such algorithms are usually exponential. 
	\end{itemize}
\end{frame}
\section{Tail Recursion}
\begin{frame}
	\frametitle{Tail Recursion}
	\begin{block}{Tail Recursion}
		Tail recursion is a special kind of recursion where the recursive call is the very last thing in the function. It's a function that does not do anything at all after recursing.
		\begin{center}
				\begin{algorithmic}[1]
					\Procedure{recurse}{$p_0,p_1,\ldots,p_{n-1}$}
					\If{$g(p_0,p_1,\ldots,p_{n-1})$}
					\State\Return{$c$}
				\Else
					\State\Return{\Call{recurse}{$p_0',p_1',\ldots,p_{n-1}'$}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
		\end{center}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Tail Recursion}
	\begin{block}{Example}
				\begin{algorithmic}[1]
					\Procedure{gcd}{$a,b$}
					\If{$b=0$}
					\State\Return{$a$}
				\Else
					\State\Return{\Call{gcd}{$b,a$ mod $b$}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\section{Linear Recursion}
\begin{frame}
	\frametitle{Linear Recursion}
	\begin{block}{Linear Recursion}
		A linear recursive function is a function that only makes a single call to itself each time the function runs, and th recusive call is not the last operation in the function
				\begin{algorithmic}[1]
					\Procedure{recurse}{$p_0,p_1,\ldots,p_{n-1}$}
					\If{$g(p_0,p_1,\ldots,p_{n-1})$}
					\State\Return{$c$}
				\Else
					\State\Return{$f$(\Call{recurse}{$p_0',p_1',\ldots,p_{n-1}'$})}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Linear Recursion}
	\begin{block}{Example}
				\begin{algorithmic}[1]
					\Procedure{factorial}{$n$}
					\If{$n=0$}
					\State\Return{$1$}
				\Else
					\State\Return{$n\times$ \Call{factorial}{$n-1$}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\section{Multiple recursion}
\begin{frame}
	\frametitle{Multiple Recursion}
	\begin{block}{Multiple Recursion}
		A multiple recursive function is like a \textit{Linear recursive} function, but there are more than one calls to itself.
				\begin{algorithmic}[1]
					\Procedure{recurse}{$p_0,p_1,\ldots,p_{n-1}$}
					\If{$g(p_0,p_1,\ldots,p_{n-1})$}
					\State\Return{$c$}
				\Else
					\State\Return{$f$(\Call{recurse}{$p_0^0,p_1^0,\ldots,p_{n-1}^0$}, \Call{recurse}{$p_0^1,p_1^1,\ldots,p_{n-1}^1$},$\ldots$, \Call{recurse}{$p_0^{m-1},p_1^{m-1},\ldots,p_{n-1}^{m-1}$})}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Multiple Recursion}
	\begin{block}{Example}
			\begin{algorithmic}[1]
				\Procedure{fibonacci}{$n$}
				\If{$n=0$}
					\State\Return{$0$}
				\Else
					\If{$n=1$}
						\State\Return{$1$}
					\Else
						\State\Return{\Call{fibonacci}{$n-1$} +  \Call{fibonacci}{$n-2$}}
					\EndIf
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\section{Nested Recursion}
\begin{frame}
	\frametitle{Nested Recursion}
	\begin{block}{Nested Recursion}
		In nested recursion, one of the arguments to the recursive function is the recursive function itself. These functions tend to grow extremely fast. A good example is the classic mathematical function: \textit{Ackermann's function}. It grows very quickly (even for small values of $x$ and $y$, $ackermann(x,y)$ is extremely large) and it cannot be computed with only definite iteration; it requires indefinite iteration 
			\begin{algorithmic}[1]
				\Procedure{recurse}{$x,y$}
				\If{$g(x,y)$}
					\State\Return{$c$}
				\Else
					\State\Return{\Call{recurse}{$x'$,\Call{recurse}{$x''$, $y''$}}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Nested Recursion}
	\begin{block}{Example}
			\begin{algorithmic}[1]
				\Procedure{ackermann}{$x,y$}
				\If{$x=0$}
					\State\Return{$y+1$}
				\Else
					\If{$y=0$}
						\State\Return{\Call{ackermann}{$x-1,1$}}
					\Else
						\State\Return{\Call{ackermann}{$x-1$,\Call{ackermann}{$x$, $y-1$}}}
					\EndIf
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}

\section{Recursive to iterative transformation}

\begin{frame}
	\frametitle{Recursive to iterative transformation}
	\begin{itemize}
		\item \textit{Tail recursion} is the easiest one to convert to iterative. We only have to iterate over the parameters until we get to the \textit{base case}.
		\item \textit{Linear Recursion}, we have to convert the \textit{Linear Recursive} fucntion to a \textit{Tail Recursive} function. This is generally carried out by adding a new parameter to the function, which acts as an \textit{accumulator}
		\item \textit{Nested Recursion} is generally converted to a \textit{Tail Recursion} form by adding a \textit{Stack} to its parameters and using the \textit{fold/unfold} technique.
		\item \textit{Multiple Recursion} is usually converted to a \textit{Nested Recursion} form by adding a new parameter and generalizing its \textit{range}, that is, what it returns. We already know how to convert a \textit{Nested Recursion} form to a \textit{Tail Recursion} form
	\end{itemize}
\end{frame}
\begin{frame}
	\frametitle{Tail Recursion to Iterative Transformation}
	Let's convert recursive \textit{GCD} to an iterative version.
	\begin{block}{Recursive Version}
				\begin{algorithmic}[1]
					\Procedure{gcd}{$a,b$}
					\If{$b=0$}
					\State\Return{$a$}
				\Else
					\State\Return{\Call{gcd}{$b,a$ mod $b$}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}	
\end{frame}
\begin{frame}
	\frametitle{Tail Recursion to Iterative Transformation}
	Let's convert recursive \textit{GCD} to an iterative version.
	\begin{block}{Iterative Version}
				\begin{algorithmic}[1]
					\Procedure{iterative-gcd}{$a,b$}
					\While{$b\neq0$}
						\State $tmp \gets a$ \Comment {We save $a$ temporally since we need its value to update $b$}
						\State $a\gets b$
						\State $b \gets $ $tmp$ $mod$ $b$
					\EndWhile
					\State\Return{$a$}
				\EndProcedure
			\end{algorithmic}
	\end{block}	
\end{frame}
\begin{frame}
	\frametitle{Tail Recursion to Iterative Transformation}
	As you see the transformation is straightforward. There are two differences:
	\begin{itemize}
		\item We use $b\neq 0$ in the \textbf{while} condition since the iteration is to simulate the recursive call
		\item We introduce the $tmp$ variable to keep the current value of $a$ which is needed to update $b$ for the next iteration.
	\end{itemize}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	Now, we will transform \textit{factorial} recursive version into an iterative one.
	\begin{block}{Recursive Version}
				\begin{algorithmic}[1]
					\Procedure{factorial}{$n$}
					\If{$n=0$}
					\State\Return{$1$}
				\Else
					\State\Return{$n\times$ \Call{factorial}{$n-1$}}
				\EndIf
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	To do so, we first have to transform it to a \textit{Tail Recursion} version. We will do this by proposing a new function which for some initial values of its parameters it is the same as \textit{factorial}. In this case, we will add a new $m$ parameter. This will be an integer and it will accumulate $n\times n-1\times n-2\times \ldots$
	\begin{block}{Recursive Version}
			\begin{algorithmic}[1]
				\Procedure{t-factorial}{$n,m$}
					\State\Return{$m \times$ \Call{factorial}{$n$}}
				\EndProcedure
			\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	Let's \textbf{unfold} the definition of \textit{factorial(n)}
	\begin{block}{Unfolding...}
		\begin{algorithmic}[1]
			\Procedure{t-factorial}{$n,m$}
			\If{$n = 0$}
				\State\Return{$m \times 1$}
			\Else
				\State\Return{$m\times n\times$\Call{factorial}{$n-1$}}
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	If we take a closer look at $m \times n \times factorial(n-1)$ and we use the associative property of multiplication operation, we have this $(m\times n) \times factorial(n-1)$. Now, by the definition of $t-factorial$, 
	\begin{equation}
		(m\times n) \times factorial(n-1) = t-factorial(n-1,m \times n)
	\end{equation}
	This is called \textbf{fold}, which is the inversion of \textbf{unfold}.
	\begin{itemize}
		\item \textbf{fold} means replacing the expression definition by its function invocation
		\item \textbf{unfold} means replacing the function invocation by its definition
	\end{itemize}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	We finally got a \textit{Tail Recursive} version
	\begin{block}{Tail Recursive Version} 
		\begin{algorithmic}[1]
			\Procedure{t-factorial}{$n,m$}
			\If{$n = 0$}
				\State\Return{$m \times 1$}
			\Else
				\State\Return{\Call{t-factorial}{$n-1, m \times n$}}
			\EndIf
			\EndProcedure
		\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	\begin{block}{Iterative Version of $t-factorial$}
		\begin{algorithmic}[1]
			\Procedure{iterative-t-factorial}{$n,m$}
			\While{$n \neq 0$}
				\State $m \gets m \times n$
				\State $n \gets n-1$
			\EndWhile
			\State\Return{$m$}
			\EndProcedure
		\end{algorithmic}
	\end{block}
\end{frame}
\begin{frame}
	\frametitle{Linear Recursion to Iterative Transformation}
	\textit{iterative-t-factorial} is a function such that its range is larger than the range of \textit{factorial} function, but it includes \textit{factorial} range. We said at the beginning that both functions will be the same for some initial parameters value. In this case, such parameter value if $m = 1$. Thus, our \textit{iterative-factorial} is
	\begin{block}{Iterative Version of $factorial$}
		\begin{algorithmic}[1]
			\Procedure{iterative-factorial}{$n$}
			\State\Return{\Call{iterative-t-factorial}{$n,1$}}
			\EndProcedure
		\end{algorithmic}
	\end{block}
\end{frame}
\section{The important things}

\begin{frame}
	\frametitle{The important things}

	\begin{enumerate}
	        \item This just shows the effect of the style
		\item It is not a Beamer tutorial
		\item Read the Beamer manual for more help
		\item Contact me only concerning the style file
	\end{enumerate}
\end{frame}

\section{Analysis of the work}

\begin{frame}
	  \frametitle{Analysis of the work}

	    This style file gives your slides some nice Radboud branding.
	    When you know how to work with the Beamer package it is easy to use.
	    Just add:\\ ~~~$\backslash$usepackage$\{$ru$\}$ \\ at the top of your file.
\end{frame}

\section{Conclusion}

\begin{frame}
	  \frametitle{Conclusion}

	  \begin{itemize}
	  	\item Easy to use
		\item Good results
	  \end{itemize}
\end{frame}
\end{document}
